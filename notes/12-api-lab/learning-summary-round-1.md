---
title: API 实验学习总结（第 1 轮）
tags: [api, http, python, debug, summary]
level: core
updated: 2026-02-13
---

# API 实验学习总结（第 1 轮）

本轮完成实验：

- `01_get_request.py`
- `02_post_json.py`
- `03_auth_header.py`
- `04_timeout_retry.py`
- `05_async_concurrency.py`

## 一、我已经掌握的核心能力

1. 能看懂一次 API 调用的完整闭环

- 请求组成：`URL + Method + Headers + Params/Body + Timeout`
- 响应组成：`Status Code + Headers + Body`
- 能通过回显服务核对“我发了什么”和“服务端收到了什么”

2. 能区分常见传参方式

- `GET + params`：参数在 URL 上，适合查询
- `POST + json`：数据在请求体，适合提交结构化对象

3. 能理解认证头的基本语义

- `Authorization: Bearer <token>` 是常见认证方式
- 无 token 常见返回 `401`，有 token 才可能通过

4. 能处理基础稳定性问题

- 知道为什么必须设置 `timeout`
- 知道重试要配合退避（避免瞬时重压）
- 能识别 `Timeout` 与一般请求异常

5. 初步理解异步并发模型

- `asyncio + httpx.AsyncClient + gather` 可并发发请求
- 并发总耗时通常接近“最慢请求”，不是所有请求耗时之和

## 二、5 个实验分别解决了什么问题

1. 实验 01：验证 GET 查询参数与响应解析流程

- 学到如何验证 `status=200`、`Content-Type=application/json`
- 学到如何查看服务端回显的 `args/headers/url`

2. 实验 02：验证 POST JSON 的请求体语义

- 学到 `json=payload` 与 `Content-Type` 的关系
- 学到 JSON 可以传递嵌套对象与数组

3. 实验 03：验证认证头与状态码关系

- 学到认证失败与成功的最小模型（`401` vs `200`）

4. 实验 04：验证超时与重试机制

- 学到重试流程：失败 -> 等待 -> 再试
- 学到指数退避基本思想：`1s -> 2s -> 4s`

5. 实验 05：验证异步并发效果

- 学到批量任务调度与统一汇总输出
- 学到并发吞吐提升的直观结果

## 三、本轮踩坑与纠正

1. 把打印文案当成真实参数

- 问题：`expect timeout due to timeout=1.0` 是字符串，不会随代码参数自动变化
- 改进：打印时使用变量拼接，保证“日志即事实”

2. 对 timeout 语义理解过于绝对

- 问题：误以为 timeout 是“整次请求总时长硬上限”
- 修正：在 `requests/httpx` 中，连接与读写阶段的 timeout 语义需分别理解

3. 容易把回显服务当真实业务服务

- 修正：`httpbin` 主要用于调试，不做完整业务校验

## 四、代码层面的评审结论（第 1 版）

1. 当前实验代码优点

- 结构清晰，分模块组织合理
- 可运行、可观察、可复现

2. 下一步可改进点

- 并发实验增加异常收集，避免单任务失败导致整批中断
- 显式记录失败请求的错误类型和失败率
- 将并发数、URL、超时参数化（命令行可配置）

## 五、方法论沉淀（以后写 API 代码的固定步骤）

1. 先写单请求（确保能成功）
2. 再加日志（请求+响应+耗时）
3. 再加超时与异常处理
4. 再加重试与退避
5. 最后再做并发和统计

## 六、下一轮学习计划（Round 2）

1. 新增“本地 Mock API”实验，避免公网波动影响结果
2. 补充 `pytest` 测试，形成可回归实验集
3. 在并发实验中加入成功率、失败率、P95 延迟统计
4. 引入限流场景（429）与幂等重试策略

## 七、一句话总结

本轮已从“会调用 API”升级到“能解释 API 调用机制，并具备基础稳定性与并发意识”。
